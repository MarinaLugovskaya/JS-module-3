<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>



МОДУЛЬ 4
Задача 2  Колбэк-функции
Дополни функцию makeMessage так, чтобы она ожидала вторым параметром (параметр callback) колбэк-функцию и возвращала ее вызов. Функция deliverPizza или makePizza будет передаваться как колбэк и ожидать аргументом имя готовой доставляемой пиццы.
Тесты
Объявлена функция deliverPizza.
Объявлена функция makePizza.
Объявлена функция makeMessage.
Функция makeMessage принимает два параметра, названые согласно задания, pizzaName и callback.
Вызов makeMessage('Роял гранд', makePizza) возвращает строку 'Пицца Роял гранд готовится, ожидайте...'.
Вызов makeMessage('Ультрасыр', deliverPizza) возвращает строку 'Доставляем пиццу Ультрасыр.'.

Задача 3 Инлайн-колбэки
Дополни второй вызов функции makePizza(pizzaName, callback), передав вторым аргументом инлайн колбэк-функцию eatPizza(pizzaName), которая логирует строку 'Едим пиццу <имя пиццы>'.
Тесты
Объявлена функция makePizza.
Функция makePizza принимает два параметра.
Вторым аргументом при вызове makePizza('Ультрасыр') передана функция eatPizza с единственным параметром pizzaName. -->

<!-- Задача 4 Несколько колбэков
еобходимо написать логику обработки заказа пиццы. Выполни рефакторинг метода order так, чтобы он принимал вторым и третим параметрами два колбэка onSuccess и onError.

Если в свойстве pizzas нет пиццы с названием из параметра pizzaName, метод order должен возвращать результат вызова колбэка onError, передавая ему аргументом строку 'В ассортименте нет пиццы с названием <имя пиццы>.'
Если в свойстве pizzas есть пицца с названием из параметра pizzaName, метод order должен возвращать результат вызова колбэка onSuccess, передавая ему аргументом имя заказанной пиццы.
После объявления объекта pizzaPalace мы добавили колбэки и вызовы методов. Пожалуйста ничего там не меняй.

Тесты
Метод order объявляет три параметра.
Вызов pizzaPalace.order('Аль Копчино', makePizza, onOrderError) возвращает 'Ваш заказ принят. Готовим пиццу Аль Копчино.'.
Вызов pizzaPalace.order('Четыре нарезона', makePizza, onOrderError) возвращает 'Ваш заказ принят. Готовим пиццу Четыре нарезона.'.
Вызов pizzaPalace.order('Биг майк', makePizza, onOrderError) возвращает 'Ошибка! В ассортименте нет пиццы с названием Биг майк.'.
Вызов pizzaPalace.order('Венская', makePizza, onOrderError) возвращает 'Ошибка! В ассортименте нет пиццы с названием Венская.'.

Задача 5 Контекст вызова функции
Выполни рефакторинг методов объекта pizzaPalace, расставив отсутствующие this в местах обращения к свойствам и методам объекта.

Задача 6 Аккаунт пользователя
Перед увольнением разработчик сломал исходный код управления аккаунтами пользователей нашего сервиса доставки еды. Выполни рефакторинг методов объекта customer, расставив отсутствующие this при обращении к свойствам объекта.

После объявления объекта мы добавили вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй. -->
<!-- 
Задача 7 Метод call
Сервису приготовления и доставки еды требуется функция генерации сообщений о статусе заказа.

Дополни функцию composeMessage(position) так, чтобы она возвращала строку в формате 'Готовим <блюдо> для <почта>. Ваш заказ <позиция>-й в очереди.' Позиция это значение параметра position - позиция элемента в массиве (на единицу больше чем индекс).

Не объявляй дополнительные параметры функции composeMessage(position).
Используй call для вызова функции в контексте одного объекта-заказа.
Используй this в теле функции для доступа к свойствам объекта-заказа в контексте которого она была вызывана.
Дополни код так, чтобы в переменной messages получился массив сообщений о статусе заказов из массива orders с помощью цикла for.

Тесты
Объявлена переменная orders.
Значение переменной orders это исходный массив объектов-заказов.
Объявлена функция composeMessage(position).
У функции composeMessage объявлен один параметр position.
В теле функции composeMessage используется this.
Функция composeMessage вызывается методом call внутри цикла for.
Объявлена переменная messages.
Значение переменной messages это массив ['Готовим Burger для solomon@topmail.ua. Ваш заказ 1-й в очереди.', 'Готовим Pizza для artemis@coldmail.net. Ваш заказ 2-й в очереди.', 'Готовим Taco для jacob@mail.com. Ваш заказ 3-й в очереди.'].

Задача 8 Метод apply
Выполни рефакторинг кода так, чтобы функция composeMessage(position) вызывалась методом apply.
Тесты
Объявлена переменная orders.
Значение переменной orders это исходный массив объектов-заказов.
Объявлена функция composeMessage(position).
У функции composeMessage объявлен один параметр position.
В теле функции composeMessage используется this.
Функция composeMessage вызывается методом apply.
Объявлена переменная messages.
Значение переменной messages это массив ['Готовим Burger для solomon@topmail.ua. Ваш заказ 1-й в очереди.', 'Готовим Pizza для artemis@coldmail.net. Ваш заказ 2-й в очереди.', 'Готовим Taco для jacob@mail.com. Ваш заказ 3-й в

Задача 9 Метод bind
Функция composeMessage(customerName) создаёт приветственные сообщения для ресторанов. Дополни код так, чтобы в переменных pizzaPalaceComposer и burgerShackComposer были её копии с привязанным контекстом к соответствующим объектам.

Задача 10 Метод bind и методы объекта

Сервису рассылки электронной почты необходимо добавить логирование действий для сбора статистики. Функция logAndInvokeAction(email, action) ожидает почту и действие которое нужно выполнить - ссылку на метод объекта service. Сбор статистики симулируется логированием строки. Разберись и дополни код так, чтобы он работал верно.

Тесты
Объявлена переменная service.
Значение переменной service это оригинальный объект.
Объявлена функция logAndInvokeAction(email, action).
Переменной firstInvoke присвоена строка 'Почта kiwi@mail.uk добавлена в рассылку.'.
Первый вызов logAndInvokeAction с почтой kiwi@mail.uk и методом service.subscribe привязан к объекту service.
Переменной secondInvoke присвоена строка 'Почта poly@hotmail.de удалена из рассылки.'. -->

<!-- 
МОДУЛЬ 5
Задача 2
Измени код, построив цепочку прототипов так, чтобы объект ancestor был прототипом для parent, а тот в свою очередь был прототипом для child.

Задача 3 Функция-конструктор
Объяви функцию-конструктор Car которая принимает три параметра:

brand - марка автомобиля.
model - модель автомобиля.
price - цена автомобиля.
Функция Car должна создавать объект с одноимёнными свойствами brand, model и price, значениями которых должны быть переданные аргументы во время её вызова с оператором new.

Задача 4 Объект настроек
Выполни рефакторинг функции-конструктора Car так, чтобы она принимала один параметр - объект со свойсвами brand, model и price. Деструктуризируй объект в сигнатуре (подписи) функции.
function Car(brand, model, price) {
  this.brand = brand;
  this.model = model;
  this.price = price;
}

Задача 5 Свойство prototype
Добавь в свойство prototype функции-конструктора Car два метода:

getPrice() - возвращает значение свойства price из объекта который его будет вызывать.
changePrice(newPrice) - обновляет значение свойства price у объекта который его будет вызывать на newPrice. -->

<!-- Задача 6 Хранилище
С помощью Function Declaration напиши функцию-конструктор Storage, которая будет создавать объекты для управления складом товаров. Функция ожидает только один аргумент - начальный массив товаров, который записывается на создаваемый объект в свойство items.

Добавь методы на прототип:

getItems() - возвращает массив текущих товаров в свойстве items объекта, который вызывает этот метод.
addItem(newItem) - принимает новый товар newItem и добавляет его в массив товаров в свойстве items объекта, который вызывает этот метод.
removeItem(item) - принимает товар item и удаляет его из массива товаров в свойстве items объекта, который вызывает этот метод.
Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.

Задача 7 Конструктор строк
С помощью Function Declaration напиши функцию-конструктор StringBuilder, которая принимает один параметр baseValue - произвольную строку, которая записывается на создаваемый объект в свойство value.

Добавь методы на прототип:

getValue() - возвращает текущее значение свойства value.
padEnd(str) - получает парметр str (строку) и добавляет её в конец значения свойства value объекта, который вызывает этот метод.
padStart(str) - получает парметр str (строку) и добавляет её в начало значения свойства value объекта, который вызывает этот метод.
padBoth(str) - получает парметр str (строку) и добавляет её в начало и в конец значения свойства value объекта, который вызывает этот метод. -->

<!-- Задача 9 Конструктор класса

Выполни рефакторинг кода, заменив функцию-конструктор Car на класс с методом-конструктором, принимающим объект.
function Car({ brand, model, price }) {
  this.brand = brand;
  this.model = model;
  this.price = price;
}

Задача 10 Методы класса
Добавь классу Car две метода.

getPrice() - возвращает значение свойства price из объекта который его будет вызывать.
changePrice(newPrice) - обновляет значение свойства price у объекта который его будет вызывать на newPrice.
class Car {
  constructor({ brand, model, price }) {
    this.brand = brand;
    this.model = model;
    this.price = price;
  }
}

Задача 11 Приватные свойства
Выполни рефакторинг класса Car так, чтобы свойство brand было приватным и добавь два метода для публичного интерфейса, для чтения и изменения этого свойства.

getBrand() - возвращает значение приватного свойства brand.
changeBrand(newBrand) - изменяет значение приватного свойства brand на newBrand.
class Car {
  constructor({ brand, model, price }) {
    this.brand = brand;
    this.model = model;
    this.price = price;
  }
}

Задача 12 Хранилище 2.0
Выполни рефакторинг заменив функцию-конструктор Storage на класс с методами. Сделай так, чтобы свойство items было приватным.

Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
function Storage(items) {
  this.items = items;
}

Storage.prototype.getItems = function () {
  return this.items;
};

Storage.prototype.addItem = function (newItem) {
  this.items.push(newItem);
};

Storage.prototype.removeItem = function (item) {
  const itemIndex = this.items.indexOf(item);
  this.items.splice(itemIndex, 1);
};

// Пиши код выше этой строки
const storage = new Storage(["Нанитоиды", "Пролонгер", "Антигравитатор"]);
console.log(storage.getItems()); // ["Нанитоиды", "Пролонгер", "Антигравитатор"]
storage.addItem("Дроид");
console.log(storage.getItems()); // ["Нанитоиды", "Пролонгер", "Антигравитатор", "Дроид"]
storage.removeItem("Пролонгер");
console.log(storage.getItems()); // ["Нанитоиды", "Антигравитатор", "Дроид"]


Задача 13 Конструктор строк 2.0
Выполни рефакторинг заменив функцию-конструктор StringBuilder на класс с методами. Сделай так, чтобы свойство value было приватным.

Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
function StringBuilder(baseValue) {
  this.value = baseValue;
}

StringBuilder.prototype.getValue = function () {
  return this.value;
};

StringBuilder.prototype.padEnd = function (str) {
  this.value += str;
};

StringBuilder.prototype.padStart = function (str) {
  this.value = str + this.value;
};

StringBuilder.prototype.padBoth = function (str) {
  this.padStart(str);
  this.padEnd(str);
};

// Пиши код выше этой строки
const builder = new StringBuilder('.');
console.log(builder.getValue()); // '.'
builder.padStart('^');
console.log(builder.getValue()); // '^.'
builder.padEnd('^');
console.log(builder.getValue()); // '^.^'
builder.padBoth('=');
console.log(builder.getValue()); // '=^.^='


Задача 14 Геттеры и сеттеры
Выполни рефакторинг класса Car. Сделай свойства model и price приватными, также как #brand. Стандартизируй публичный интерфейс класса заменив уже объявленные методы на геттеры и сеттеры brand, model и price для взаимодействия с приватными свойствами.
class Car {
  model;
  price;
  #brand;

  constructor({ brand, model, price }) {
    this.#brand = brand;
    this.model = model;
    this.price = price;
  }

  getBrand() {
    return this.#brand;
  }

  changeBrand(newBrand) {
    this.#brand = newBrand;
  }

  getModel() {
    return this.model;
  }

  updateModel(newModel) {
    this.model = newModel;
  }

  getPrice() {
    return this.price;
  }

  setPrice(newPrice) {
    this.price = newPrice;
  }
}

Задача 16 Статические методы
Добавь классу Car публичный статический метод checkPrice(price), принимающий цену автомобиля. Метод должен сравнить значения параметра price и приватного статического свойства MAX_PRICE.

Если цена автомобиля превышает максимальную, метод должен вернуть строку 'Внимание! Цена превышает допустимую.'.
В противном случае метод должен вернуть строку 'Всё хорошо, цена в порядке.'.
Под объявлением класса мы добавили инициализацию экземпляра и вызовы методов, чтобы показать как будет использоваться метод checkPrice(price).

Задача 17 Наследование классов
В приложении нужен администратор с возможностью добавлять почты пользователей в чёрный список.

Объяви класс Admin, который наследует от класса User.
Добавь классу Admin публичное статическое свойство AccessLevel (уровень доступа), значение которого это объект { BASIC: 'basic', SUPERUSER: 'superuser' }. -->


  <!-- <script src="js/js/task-20.js"></script>
  <script src="js/js/task-22.js"></script>
  <script src="js/js/task-23.js"></script>
  <script src="js/js/task-24.js"></script>
  <script src="js/js/task-25.js"></script>
  <script src="js/js/task-26.js"></script>
  <script src="js/js/task-27.js"></script>
  <script src="js/js/task-28.js"></script>
  <script src="js/js/task-29.js"></script>
  <script src="js/js/task-30.js"></script>
  <script src="js/js/task-31.js"></script>
  <script src="js/js/task-32.js"></script>
  <script src="js/js/task-33.js"></script>
  <script src="js/js/task-34.js"></script>
  <script src="js/js/task-36.js"></script>
  <script src="js/js/task-37.js"></script>
  <script src="js/js/task-38.js"></script>
  <script src="js/js/task-39.js"></script>
  <script src="js/js/task-40.js"></script> -->


  <!-- 
  <script src="/js_module-4/task-2.js"></script>
  <script src="/js_module-4/task-3.js"></script>
  <script src="/js_module-4/task-4.js"></script>
  <script src="/js_module-4/task-5.js"></script>
  <script src="/js_module-4/task-6.js"></script>
  <script src="/js_module-4/task-7.js"></script>
  <script src="/js_module-4/task-8.js"></script>
  <script src="/js_module-4/task-9.js"></script>
  <script src="/js_module-4/task-10.js"></script> -->



  <!-- <script src="js_module-5/task-2.js"></script>
  <script src="js_module-5/task-3.js"></script>
  <script src="js_module-5/task-4.js"></script>
  <script src="js_module-5/task-5.js"></script>
  <script src="js_module-5/task-6.js"></script>
  <script src="js_module-5/task-7.js"></script>
  <script src="js_module-5/task-9.js"></script>
  <script src="js_module-5/task-10.js"></script>
  <script src="js_module-5/task-11.js"></script>
  <script src="js_module-5/task-12.js"></script>
  <script src="js_module-5/task-13.js"></script>
  <script src="js_module-5/task-14.js"></script>
  <script src="js_module-5/task-15.js"></script>
  <script src="js_module-5/task-16.js"></script>
  <script src="js_module-5/task-17.js"></script>
  <script src="js_module-5/task-18.js"></script>
  <script src="js_module-5/task-19.js"></script> -->


  <!-- <script src="/js_module-6.js/task-1.js"></script>
  <script src="/js_module-6.js/task-2.js"></script>
  <script src="/js_module-6.js/task-3.js"></script>
  <script src="/js_module-6.js/task-4.js"></script>
  <script src="/js_module-6.js/task-5.js"></script>
  <script src="/js_module-6.js/task-6.js"></script>
  <script src="/js_module-6.js/task-7.js"></script>
  <script src="/js_module-6.js/task-8.js"></script>
  <script src="/js_module-6.js/task-9.js"></script>
  <script src="/js_module-6.js/task-10.js"></script>
  <script src="/js_module-6.js/task-11.js"></script>
  <script src="/js_module-6.js/task-12.js"></script>
  <script src="/js_module-6.js/task-13.js"></script>
  <script src="/js_module-6.js/task-14.js"></script>
  <script src="/js_module-6.js/task-15.js"></script>
  <script src="/js_module-6.js/task-16.js"></script>
  <script src="/js_module-6.js/task-17.js"></script>
  <script src="/js_module-6.js/task-18.js"></script>
  <script src="/js_module-6.js/task-19.js"></script>
  <script src="/js_module-6.js/task-20.js"></script>
  <script src="/js_module-6.js/task-21.js"></script>
  <script src="/js_module-6.js/task-22.js"></script>
  <script src="/js_module-6.js/task-23.js"></script>
  <script src="/js_module-6.js/task-24.js"></script>
  <script src="/js_module-6.js/task-25.js"></script>
  <script src="/js_module-6.js/task-26.js"></script>
  <script src="/js_module-6.js/task-27.js"></script>
  <script src="/js_module-6.js/task-28.js"></script>
  <script src="/js_module-6.js/task-29.js"></script>
  <script src="/js_module-6.js/task-30.js"></script>
  <script src="/js_module-6.js/task-31.js"></script>
  <script src="/js_module-6.js/task-32.js"></script>
  <script src="/js_module-6.js/task-33.js"></script>
  <script src="/js_module-6.js/task-34.js"></script>
  <script src="/js_module-6.js/task-35.js"></script>
  <script src="/js_module-6.js/task-36.js"></script>
  <script src="/js_module-6.js/task-37.js"></script>
  <script src="/js_module-6.js/task-38.js"></script>
  <script src="/js_module-6.js/task-39.js"></script>
  <script src="/js_module-6.js/task-40.js"></script>
  <script src="/js_module-6.js/task-41.js"></script>
  <script src="/js_module-6.js/task-42.js"></script>
  <script src="/js_module-6.js/task-43.js"></script>
  <script src="/js_module-6.js/task-44.js"></script> -->

</body>
</html> 